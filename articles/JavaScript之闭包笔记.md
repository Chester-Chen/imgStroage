data: 2020.02.13

# 闭包笔记

眨眼2月都过了一半，疫情也爆发了1个多月了，等回校后就得准备春招的事了。看了些前端的面经，挺多人都有遇到面试闭包的问题。这里我也要着手了解一下。

# 什么是闭包

一句话。闭包是指有权访问另一个函数作用域中的变量的**函数**

创建闭包的常见方式，就是在一个函数内部创建另一个函数。

在这之前先学习一下作用域链的概念。当某个函数被调用时，会创建一个执行环境及相应的作用域链，然后，使用arguments和其他命名参数的值来初始化函数的活动对象。

```js

function outer() {
    let num = 1;

    function innner() {
        console.log(num++);
    }
    innner();
}
var a = outer();        // 1

```

![](https://github.com/Chester-Chen/imgStroage/blob/master/images/2020.02.13/01.png?raw=true)

当调用`outer()`时，会创建一个包含arguments的`活动对象`，如果函数有参数，则会创建对应的值。全局执行环境的变量对象在outer()的作用域链中处于第二位

一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但是，闭包的情况又有所不同。

下面开始了解闭包。

```js

function outer() {
    let num = 1;

    return function innner() {
        console.log(num++);
    }
    
}
var a = outer();        // 这里执行outer()，把inner()函数返回给变量a
a();                    // 1
a();                    // 2
a();                    // 3

```

在一个函数内部定义的函数会将包含函数的活动对象添加到它的作用域链中。所以inner()函数的作用域链中，会包含outer()
函数的活动对象。

我们可以看到上面的例子中，执行了3次a()，其值递增1。这里要注意的是，当outer()函数执行完毕后，它的执行环境作用域链会被销毁，但是，其活动对象仍会留在内存中，所以说，outer环境中的num会被引用3次，其值会被递增。简单来说，就是，外部环境的值还在被使用，活动对象就不会被销毁。亦可通过，设置内部函数的值为null，解除该函数的引用，通知gc将其回收。


若改动如下。
```js

function outer() {
    let num = 1;

    return function innner() {
        console.log(num++);
    }
    
}

var a = outer();        // 这里执行outer()，把inner()函数返回给变量a
a();                    // 1
a();                    // 2
a();                    // 3
// 我们都知道Function引用类型，所以a()会共享数据。

var b = outer();
b();                    // 1
b();                    // 2
b();                    // 3
// b会共享数据

```

发现b()的值亦是从1递增，当用变量b接收inner()时，会另外复制一份相应的执行环境。a与b各享其值。










